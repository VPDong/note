# CSRF漏洞详解

跨站请求伪造CSRF(Cross-Site Request Forgery)存在巨大的危害性。该攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在未授权的情况下执行在权限保护之下的操作。

## 流程

```sequence
participant 黑客
participant 用户
participant 正常服务器
participant 恶意服务器

黑客->正常服务器:发现正常服务器的CSRF漏洞
黑客->恶意服务器:设计恶意网站
用户->正常服务器:登陆并浏览正常网站
正常服务器-->用户:返回验证通过，并在用户浏览器设置cookie
用户->恶意服务器:用户在没有退出正常网站情况下访问恶意网站
恶意服务器-->用户:返回带有恶意脚本(访问正常网站)的网页
用户->正常服务器:恶意脚本执行访问(带着正常网站的cookie)
正常服务器-->正常服务器:执行恶意脚本发出的请求(如转账等)
```

原理：SOP可以通过html tag加载资源，且SOP不阻止接口请求而是拦截请求结果，CSRF恰恰占了这两个便宜。所以 SOP不能作为防范CSRF的方法。

虽然同源策略会阻止响应，但依然会发出请求。因为执行响应拦截的是浏览器而不是后端程序。事实上请求已经发到服务器并返回了结果，但是迫于安全策略，浏览器不允许你继续进行 js 操作，所以报出你熟悉的 `blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.`，但是请求已经发到服务器并被处理了。**所以再强调一次，同源策略不能作为防范 CSRF 的方法**。

+ 受害者Bob在银行有一笔存款，通过对银行的网站发送请求`http://bank.example/withdraw?account=bob&amount=1000000&for=bob2`可以使Bob把1000000的存款转到bob2的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的session，并且该session的用户Bob已经成功登陆。
+ 黑客Alice自己在该银行也有账户，他知道上文中的URL可以把钱进行转帐操作。Alice可以自己发送一个请求给银行：`http://bank.example/withdraw?account=bob&amount=1000000&for=Alice`。但是这个请求来自Alice而非 Bob，他不能通过安全认证，因此该请求不会起作用。
+ 这时Alice想到使用CSRF的攻击方式，他先自己做一个网站，在网站中放入如下代码`src=”http://bank.example/withdraw?account=bob&amount=1000000&for=Alice`，并且通过广告等诱使Bob来访问他的网站。当Bob访问该网站时，上述 url就会从Bob的浏览器发向银行，而这个请求会附带Bob浏览器中的cookie一起发向银行服务器。但是如果Bob当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的session尚未过期，这时这个url请求就会得到响应，钱将从Bob的账号转移到Alice的账号，而Bob当时毫不知情。

## 对抗

**1、验证HTTP Referer字段**

根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。当用户通过黑客的网站发送请求到银行时，该请求的Referer是指向黑客自己的网站。因此要防御CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值。如果Referer是其他网站的话，则有可能是黑客的CSRF攻击，拒绝该请求。

这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心CSRF的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查Referer的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑非常便捷。

然而这种方法并非万无一失。原因有两个：

+ Referer的值是由浏览器提供的，虽然HTTP协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证Referer值的方法，就是把安全性都依赖于第三方(即浏览器)来保障，从理论上来讲这样并不安全。事实上对于某些浏览器，比如IE6或FF2，目前已经有一些方法可以篡改Referer值
+ 即便是使用最新的浏览器，黑客无法篡改Referer值，这种方法仍然有问题。因为Referer值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心Referer值会把组织内网中的某些信息泄露到外网中。因此用户自己可以设置浏览器使其在发送请求时不再提供Referer。当他们正常访问银行网站时，网站会因为请求没有Referer值而认为是 CSRF 攻击，拒绝合法用户的访问。

**2、在请求内容中添加token并验证 **

CSRF攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中，可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。

这种方法要比检查Referer要安全一些，token可以在用户登陆后产生并放于session之中，然后在每次请求时把token从session中拿出，与请求中的token进行比对，但这种方法的难点在于如何把token以参数的形式加入请求。对于GET请求，token将附在请求地址之后，这样URL就变成 http://url?csrftoken=tokenvalue。 而对于POST请求来说，要在form的最后加上 ，这样就把token以参数的形式加入请求了。但是在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上token是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript遍历整个dom树，对于dom中所有的a和 form标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的html代码，这种方法就没有作用，还需要程序员在编码时手动添加token。    

该方法还有一个缺点是难以保证token本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上token，黑客可以在自己的网站上得到这 token，并马上就可以发动CSRF攻击。为了避免这一点，系统可以在添加token的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加token，如果是通向外网则不加。不过即使这个csrftoken不以参数的形式附加在请求之中，黑客的网站也同样可以通过Referer来得到这个token值以发动CSRF攻击。这也是一些用户喜欢手动关闭浏览器Referer功能的原因。

**3、在请求头中添加token并验证**

这种方法也是使用token并进行验证，和上一种方法不同的是，这里并不是把token以参数的形式置于HTTP请求之中，而是把它放到HTTP头中自定义的属性里。通过XMLHttpRequest这个类，可以一次性给所有该类请求加上CSRFToken这个HTTP头属性，并把token值放入其中。这样解决了上种方法在请求中加入token的不便，同时通过XMLHttpRequest请求的地址不会被记录到浏览器的地址栏，也不用担心token会透过Referer泄露到其他网站中去。        

然而这种方法的局限性非常大。XMLHttpRequest请求通常用于Ajax方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进、后退、刷新、收藏等操作，给用户带来不便。另外对于没有进行CSRF防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为XMLHttpRequest请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。

**4、针对关键请求进行二次验证**

这个就不需多说了，各种验证码层出不穷。

## 挖掘

+ 最简单的方法就是抓取一个正常请求的数据包，如果没有Referer字段和token，那么极有可能存在CSRF漏洞
+ 如有Referer字段，但是去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞

随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞进行检测的工具，如CSRFTester，CSRF Request Builder等。 BurpSuite可以抓包后快速生成CSRF POC。以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞。

