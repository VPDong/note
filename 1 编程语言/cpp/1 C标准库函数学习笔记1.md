## 基础函数

+ `char *crypt (const char *key,const char *salt)`：使用DES算法将参数key所指的字符串加以编码，key字符串长度仅取前8个字符。参数salt为两个字符组成的字符串，由`a-z、A-Z、0-9，.和/`所组成，用来决定使用4096种不同内建表格的哪一个。函数执行成功后会返回指向编码过的字符串指针(参数key所指的字符串不会有所更动)。编码过的字符串长度为13个字符，前两个字符为参数salt代表的字符串。**使用gcc编译时需加-lcrypt**。位于unistd头文件中。
+ `void *lsearch(const void *key,const void *base,size_t *nmemb,size_t size, int (*compar) (const void*,const void*))`：利用线性搜索从通用的数组中查找数据。参数key指向欲查找的关键数据，参数base指向要被搜索的数组开头地址，参数nmemb代表数组中的元素数量，每一元素的大小则由参数size决定，最后一项参数 compar为一函数指针，这个函数用来判断两个元素是否相同，若传给compar的第一个参数所指的元素数据和第二个参数所指的元素数据不相同时则返回非0值，两个元素数据不相同则返回非0值。**如果lsearch()找不到关键数据时会主动把该项数据加入数组里**。位于stdlib头文件中。
+ `void *bsearch(const void *key,const void *base,size_t nmemb,size_t size,int (*compar) (const void*,const void*))`：利用二元搜索从排序好的数组中查找数据。参数key指向欲查找的关键数据，参数base指向要被搜索的数组开头地址，参数nmemb代表数组中的元素数量，每一元素的大小则由参数size决定，最后一项参数compar为一函数指针，这个函数用来判断两个元素之间的大小关系，若第一个参数所指的元素数据大于第二个参数所指的元素数据则必须回传大于0的值没，两个元素数据不相同则返回非0值。位于stdlib头文件中。



## I\\O函数

+ `int scanf(const char *format,...)`：根据参数format字符串来转换并格式化数据，输入源为键盘输入。格式转换的一般形式如:`%[*][size][l][h]type`。位于stdio头文件中。
+ `int sscanf(const char *str,const char *format,...)`：根据参数format字符串来转换并格式化数据，输入源为参数str的字符串，转换后的结果存于对应的参数内。位于stdio头文件中。
+ `int fscanf(FILE * stream ,const char *format,....)`：根据参数format字符串来转换并格式化数据，输入源为参数stream的文件流中读取字符串，转换后的结果存于对应的参数内。位于stdio头文件中。
+ `int printf(const char *format,...)`：根据参数format字符串来转换并格式化数据，将结果写到标准输出设备，直到出现字符串结束(’\0’)为止。格式转换的一般形式如:`%〔flags〕〔width〕〔.prec〕type`。位于stdio头文件中。
+ `int sprintf(char *str,const char *format,...)`：根据参数format字符串来转换并格式化数据，然后将结果复制到参数str所指的字符串数组，直到出现字符串结束(’\0’) 为止。使用此函数得留意堆栈溢出。位于stdio头文件中。
+ `int fprintf(FILE *stream, const char *format,...)`：根据参数format字符串来转换并格式化数据，然后将 结果输出到参数stream指定的文件中，直到出现字符串结束(‘\0 ‘)为止。位于stdio头文件中。



## STR函数

+ `void * memset(void *s ,int c, size_t n)`：将参数s所指的内存区域前n个字节以参数c填入，然后返回指向s的指针。在编写程序时，若需要将某一数组作初始化，memset()会相当方便。头文件位于string中。

  类比`char *strdup(const char *s)`：会先用maolloc()配置与参数s字符串相同的空间大小，接着将参数s字符串的内容复制到该内存地址，然后把该地址返回(该地址最后可以利用free()来释放)。

+ `void *memcpy(void *dest ,const void *src, size_t n)`：用来拷贝src所指的内存内容前n个字节到dest所指的内存地址上。与strcpy()不同的是它不会因为遇到字符串结束‘\0‘而结束。头文件位于string中。

  类比`char *strcpy(char *dest,const char *src)`：将参数src字符串拷贝到参数dest所指地址。

  类比`char *strcat(char *dest,const char *src)`：将参数src字符串拷贝到参数dest所指字符串尾。第一个参数dest要有足够的空间来容纳要拷贝的字符串。

+ `int memcmp(const void *s1,const void *s2,size_t n)`：用来比较s1和s2所指的内存区间前n个字符。字符 串大小的比较是以 ASCII 码表上的顺序来决定。头文件位于string中。

  类比`int strcmp(const char *s1,const char *s2)`：用来比较参数s1和s2字符串。字符串大小的比较是以ASCII码表上的顺序来决定。头文件位于string中。

+ `void * memchr(const void *s,int c,size_t n)`：用来从头找出开始搜寻s所指的内存内容前n个字节，直到发现第一个值为c的字节，则返回指向该字节的指针。头文件位于string中。

  类比`char *strchr(const char *s,int c)`：用来从头找出开始找出参数s字符串中第一个出现的参数c地址，然后将该字符出现的地址返回。

  类比`char *strstr(const char *haystack,const char *needle)`：从字符串haystack中搜寻字符串needle，并将第一次出现的地址返回。

+ `size_t strlen(const char *s)`：用来计算指定的字符串s的长度，不包括结束字符“\0”。头文件位于string中。



## 文件函数



## 内存函数

+ `void *alloca(size_t size)`：在栈区分配内存空间，其大小由指定的size决定。因在栈区中分配内存，故在函数返回时会自动释放此空间。位于malloc头文件中。注意该函数可移植性差，对编译器\平台有强依赖性。
+ `void *malloc(size_t size)`：在堆区配置内存空间，其大小由指定的size决定，并返回指向第一个元素的指针。位于stdlib头文件中。
+ `void *calloc(size_t nmemb，size_t size)`：在堆区配置内存空间，其大小由指定的nmemb*size决定，配置内存时会将内存内容初始化为0 ，并返回指向第一个元素的指针。位于stdlib头文件中。
+ `void *realloc(void *ptr, size_t newsize)`：把堆内存扩展到newsize。若size值比原分配的内存空间小，内存内容不会改变，且返回的指针为原来内存的首地址(即ptr)；若size值比原分配的内存空间大，则realloc不一定会返回原来的指针，原先的内容不会改变但新多出的内存则为设初始值。位于stdlib头文件中。
+ `void free(void *ptr)`：释放堆区内存。调用后ptr 所指的内存空间便会被收回。位于stdlib头文件中。
+ `void *mmap(void *start,size_t length,int prot,int flags,int fd,off_t offsize)`：建立内存映射，用来将某个文件内容映射到内存中，对该内存区域的存取即是直接对该文件内容的读写。参数start指向欲对应的内存起始地址(通常设为NULL，代表让系统自动选定地址，对应成功后该地址会返回)，参数length代表将文件中多大的部分对应到内存，参数prot代表映射区域的保护方式，参数flags会影响映射区域的各种特性，参 fd为 open()返回的文件描述词(代表欲映射到内存的文件)，参数offset为文件映射的偏移量(通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍)。通过`size_t getpagesize(void)`获取分页大小。若映射成功则返回映射区的内存起始地址。位于unistd和sys/mman头文件中。
+ `int munmap(void *start,size_t length)`：解除内存映射，用来取消参数start所指的映射内存起始地址，参数 length则是欲取消的内存大小。当进程结束或利用exec相关函数来执行其他程序时，映射内存会自动解除，但关闭对应的文件描述词时不会解除映射。位于unistd和sys/mman头文件中。



## 错误处理

C语言不提供对错误处理的直接支持，在发生错误时，大多数的C或UNIX函数调用返回1或NULL，同时会设置一个错误代码 **errno**，该错误代码是全局变量，表示在函数调用期间发生了错误。可在 errno.h 头文件中找到各种各样的错误代码。

所以C程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把errno设置为0，这是一种良好的编程习惯。0值表示程序中没有错误。

+ `char *strerror(int errnum)`：用来依参数errnum的错误代码来查询其错误原因的描述字符串，然后将该字符串指针返回。位于string头文件中。
+ `void perror(const char *s)`：将上一个函数发生错误的原因输出到标准错误 (stderr)。参数s所指的字符串会先打印出，后面再加上错误原因字符串。位于stdio头文件中。
+ `int ferror(FILE *stream)`：检查参数stream所指定的文件流是否发生了错误情况，如有错误发生则返回非0 值。





