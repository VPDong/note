## 进程管理

#### 1.1 进程控制

+ ` pid_t fork/vfork(void)`：一个现有进程可以调用该函数创建一个新进程。创建的新进程被称为子进程。该函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而父进程中返回子进程ID。fork函数的子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的**副本**，这意味着父子进程间不共享存储空间，所以父子进程谁先运行依赖于系统实现；而vfork创建的进程并不将父进程的地址空间完全复制到子进程中，所以它会保证子进程先运行，在调用exec或exit之前与父进程数据是共享的(如果在调用这两个函数之前子进程依赖于父进程的进一步动作则会导致死锁)，在调用exec或exit之后父进程才可能被调度运行。头文件位于unistd中。

+ `int nice(int inc)`：用来改变进程的进程执行优先顺序。参数inc数值越大则优先顺序排在越后面，即表示进程执行会越慢。头文件位于unistd中。

  ```c
  // nice是getpriority()和setpriority()的一种组合形式
  int nice( int increamet)
  {
     int oldpro = getpriority(PRIO_PROCESS, getpid() );
     return setpriority(PRIO_PROCESS, getpid(), oldpro + increament );
  }
  ```

+ `pid_t getpid(void)`：用来取得目前进程的进程识别码。头文件位于unistd中。

+ `pid_t waitpid(pid_t pid,int *status,int options)`：等待子进程中断或结束。首先会暂时停止目前进程的执行，直到有信号来到或子进程结束。如果在调用wait()时子进程已经结束，则wait()会立即返回子进程结束状态值。头文件位于sys/wait中。

  参数pid为欲等待的子进程识别码：

  + pid<-1表示等待进程组识别码为pid绝对值的任何子进程
  + pid=-1表示等待任何子进程，相当于wait()
  + pid=0 表示等待进程组识别码与目前进程相同的任何子进程
  + pid>0 表示等待任何子进程识别码为pid的子进程

  参数option可以为0或下面的OR组合:

  + WNOHANG：如果没有任何已经结束的子进程则马上返回，不予以等待。
  + WUNTRACED：如果子进程进入暂停执行情况则马上返回，但结束 状态不予以理会。

+ `void exit(int status)`：用来正常终结目前进程的执行，并把参数status返回给父进程，而进程所有的缓冲区数据会自动写回并关闭未关闭的文件。头文件位于stdlib中。

#### 1.2 进程通信

+ `int kill(pid_t pid,int sig)`：可以用来送参数sig指定的信号给参数pid指定的进程。参数pid与waitpid函数一样。头文件位于signal中。
+ `unsigned int alarm(unsigned int seconds)`：用来设置信号SIGALRM在经过参数seconds指定的秒数后传送给目前的进程。如果参数seconds为0，则之前设置的闹钟会被取消，并将剩下的时间返回。头文件位于unistd中。
+ `int pause(void)`：会令目前的进程暂停，直到被信号所中断。头文件位于unistd中。
+ `unsigned int sleep(unsigned int seconds)`：会令目前的进程暂停，直到达到参数seconds所指定的时间，或是被信号所中断。头文件位于unistd中。
+ `void (*signal(int signum,void(* handler)(int)))(int)`：会依参数signum指定的信号编号来设置该信号的处理函数。当指定的信号到达时就会跳转到参数handler指定的函数执行。 如果参数handler不是函数指针，则必须是两个常数之一: SIG_IGN(忽略参数signum指定的信号)或SIG_DFL(将参数signum指定的信号重设为核心预设的信号处理 方式)。头文件位于signal中。

#### 1.3 进程命令

最基础为`int system(const char *string)`，它会调用fork产生子进程，由子进程来调用/bin/sh-c string来执行参数string字符串所代表的命令，此命令执行完后随即返回原调用的进程。在调用system()期间SIGCHLD信号会被暂时搁置，SIGINT和SIGQUIT信号则会被忽略。头文件位于unistd中。

而exec系列的函数，属于替换进程映像(不产生新的进程)。把原来的进程替换掉来执行路径(或文件)指向的程序，从文件的main开始运行，执行完exec函数后原来的程序不再执行。头文件位于unistd中。*exec*族函数名称特点：

+ *l* 命令行参数列表
+ *v* 使用命令行参数数组
+ *p* 搜素*file*时使用*path*变量，file可以是name而不是绝对路径
+ *e* 使用环境变量数组，不使用进程原有的环境变量，设置新加载程序运行的环境变量

事实上，只有*execve*是真正的系统调用，其它五个函数最终都调用*execve*：

![](https://img-blog.csdn.net/20140917065519447?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG90b3R1enVvcXVhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

+ `int execvp(const char *file,char *const argv[])`：会从PATH环境变量所指的目录中查找符合参数file的文件名，找到后便执行该文件，然后将第二个参数argv传给该欲执行的文件。如`execvp(“ls”,argv)`。
+ `int execve(const char *file,char *const argv[],char *const envp[])`：第一个参数file代表文件绝对路径，第二个参数是利用数组指针来传递给执行文件，最后一个参数则为传递给执行文件的新环境变量数组。如`execve(“/bin/ls”,argv,envp)`。

使用时最好在在一系列的参数结尾处都要加上一个空参数指针，最好使用`(char*)0`。如：

```c
#include <unistd.h>
 
void main(){
    char * argv[] = {"ls", "-al", "/etc/passwd", (char *)0};
    char * envp[] = {"PATH=/bin", 0};
 
    execve("/bin/ls", argv, envp);
}
```



## 系统通信

+ `int select(int n,fd_set *readfds,fd_set *writefds,fd_set *exceptfds,struct timeval *timeout)`：用来等待文件描述词状态的改变。参数n代表最大的文件描述词加 1，参数readfds、writefds和exceptfds称为描述词组，是用来回传该描述词的读或写或例外的状况。位于sys/time、sys/types、unistd头文件中。**非常重要**。

剩下的是pipe和socket了，暂时忽略。



