## 编译流程

虽有很多IDE，但依然需要熟悉最基本的流程。代码会经过4个环节形成最终文件(更详细的可以参考《编译原理》)：

+ 预处理：去掉注释/展开头文件/宏替换/条件编译(但会保留#pragma编译器指令，因为编译器需要使用它们)

  通过`gcc -E hello.c -I <dir> -o hello.i`生成完整文件，`-I`指定头文件目录

+ 编译：检查词法\语法\语义，生成汇编

  通过`gcc -S hello.c -I <dir> -o hello.s`生成汇编文件，`-I`指定头文件目录

+ 汇编：汇编代码转换机器码

  通过`gcc -c hello.c -o hello.o`生成二进制文件，等同于`as hello.s -o hello.o`

+ 链接：链接到一起生成可执行程序

  通过`gcc hello.c -o hello`生成可执行程序。等同于`ld hello.o ... -o hello`

库是一种可执行代码的二进制形式，可以直接被操作系统载入内存执行。库文件分为静态库和动态库：

+ 静态库命令和特点：`gcc -c hello.c -o hello.o && ar -crv libhello.a hello.o && gcc main.c -o main -L <dir> -lhello `，在执行main之前**不需**将libhello.so拷贝到/usr/lib/路径下
  + 库的代码会编译进程序里面，所以静态库编译的程序比较大
  + 因静态库编译的程序不用依赖于系统的环境变量，所以有没有这个库文件均可运行
+ 动态库命令和特点：`gcc -c hello.c -o hello.o -fPIC && gcc hello.o -o libhello.so -shared && gcc main.c -o main -L <dir> -lhello`，在执行main之前**需要**将libhello.so拷贝到/usr/lib/路径下
  + 库的代码不会编译进程序里面，所以动态库编译的程序比较小
  + 因动态库编译的程序需要依赖于系统的环境变量，所以有没有这个库文件影响运行

GCC常用参数整理如下(可参考[这里](http://c.biancheng.net/gcc/))：

+ `-include <file>`：包含某个代码。功能就相当于在代码中使用` #include`
+ `-I<dir>`：用来指定搜索头文件的路径。会先到所指定的目录查找，然后再按常规的顺序去找：常规是会先在当前目录查找头文件，如果没有找到会到默认的头文件目录找
+ `-L<dir>`：用来指定搜索库的路径。会先到所指定的目录查找，然后再按常规的顺序去找：在标准库的目录找
+ `-l<file>`：用来指定程序要链接的库(必须放到命令行最后)，如果文件不是以`lib`开头，则应该直接写上库名称
+ `-static`：此选项将禁止使用动态库，所以生成文件比较大
+ `-shared`：此选项将尽量使用动态库，所以生成文件比较小
+ `-fPIC `：作用于编译阶段，告诉编译器产生与位置无关代码(Position-Independent Code)，这样一来产生的代码中就没有绝对地址了，全部使用相对地址，所以代码可以被加载器加载到内存的任意位置都可以正确的执行
+ `-w\-Wall`:不生成\生成警告信息



## 内存结构

内存结构如下(地址由下往上增长)：

![](https://img-blog.csdn.net/20161029171857434)

+ 代码段：`.text`用来存放程序执行代码，同时也可能会包含一些常量(如一些字符串常量等)。它是静态分配的且只读(RO)的，同一程序内的多个相同进程存在时共用同一个
+ 数据段：分为`.data`和`.bss`两段：
  + `.data`：也称为GVAR(global value)，存放程序中**已经初始化的非零全局变量**。它是静态分配的且可分为只读(RO)区域(保存常量)和读写(RW)区域(普通非常全局变量，静态变量就在其中)
  + `.bss`： 存放程序中**未初始化(程序开始时通常会被清零)的或零值全局变量**。它是静态分配的(static标识变量保存在这里，不需要在每次它进入和离开作用域时进行创建和销毁)
+ 堆：`heap`是自由申请的空间，按内存地址由低到高方向生长。同一进程内的多个线程存在时共用同一个
+ 栈：`stack`：是程序运行的空间，按内存地址由高到低方向生长。每个线程都会有自己的栈

内存对齐流程如下：

+ 如没有对内存对齐有明确要求，以结构体中最长的数据成员长度作为内存对齐的有效值
+ 如已经对内存对齐有明确要求，可用`#pragma pack(n)`指定，以n和结构体中最长数据成员长度中较小者为有效值

结构对齐规则如下：

+ 结构体或联合体的总大小(即sizeof的结果)，必须是其内部最大基本类型成员长度的整数倍，不足的要补齐
+ 结构体或联合体的数据成员，第一个数据成员存放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员(成员最大元素)大小的整数倍开始
  + 数组作为成员时，因数组在内存中是分开存储的，所以内存对齐时按照单个元素大小的整数倍开始存储
  + 结构作为成员时，因结构在内存中是连续存储的，所以内存对齐时按照内部最大元素大小的整数倍开始存储



## 预处理器

+ \#include：导入源代码文件
+ \#define\\#undef：定义\取消宏
+ \#ifdef\\#if\\#else\\#elif\\#endif：条件编译
+ \#pragma：发布特殊的命令到编译器中，如`#pragma pack (n)`告诉编译器将按照n个字节对齐

ANSI C定义了许多宏(在编程中可以使用这些宏，但是不能直接修改这些预定义的宏)：

+ `__FILE__`：当前文件名，一个字符串常量
+ `__DATE__`：当前日期，一个以"MM DD YYYY"(Jun 2 2012)格式表示的字符常量
+ `__TIME__`：当前时间，一个以"HH:MM:SS"(02:22:22)格式表示的字符常量

C预处理器提供了下列的运算符来帮助您创建宏：

+ `宏延续运算符(\)`：如果宏太长而单行容纳不下，则使用宏延续运算符
+ `参数数值运算符(#)`：当需要把参数转换成具体数值时，则使用参数数值运算符
+ `参数标记运算符(##)`：当需要把参数和字符串拼接成标记时，则使用参数标记运算符

\#define用来定义一个字符串常量(包括无参常量和有参常量)，本身是在预处理阶段进行字符串替换。所以在使用宏定义时要特别注意优先级(注意添加外层括号)：

```c
#define ADD(a,b) a+b

int i = 1;
int j = 2;
int s = ADD(i,j) * 3;// 实际是i+j*3，并不是想象中的(i+j)*3
```

typedef用类给数据类型起个新的别名，本身是在编译阶段由编译器执行解释的。typedef经常使用在结构\联合\枚举或指针声明一个新类型。如`typedef int* INTPTR`声明INTPTR是一个指向整型变量的指针类型。这点与#define是决然不同的，#define只是作简单的字符串替换，不表达任何含义。

```c
typedef struct Books
{
   char  title[50];
} Book;

Book book;
```



## 特殊类型

**数组**：由连续的内存位置组成(结构体或联合体的除外)

**结构**：注意结构的内存对齐。结构体特殊形式为[位域结构](https://www.runoob.com/cprogramming/c-bit-fields.html)。实现面向伪对象方法靠函数指针和static。

**联合**：注意结构的内存对齐。为联合体赋值一个成员后其他的成员数据可能受损，因其成员共用最大元素大小的内存

**指针**：是一个值为地址的类型，**void \*** 为**"无类型指针"**，意思是可指向任意类型的数据，就是说可用任意类型的指针对void指针赋值；在ANSI C标准中不允许对void指针进行一些算术运算如p++或p+=1等，因为void是无类型，那么每次算术运算就不知道该操作几个字节，而GNU中是可以的。另外void指针常用来进行C中的泛型编程。**(char *)0**为空指针NULL
或地址为0的指针，通常用于进行判空处理。指针符号优先级如下(总结下来就是解析时从右边往左边解析)：

+ `.的优先级高于*`：`*p.f`实际为`*(p.f)`，会误理解为(\*p).f
+ `[]的优先级高于*`：`int *ar[]`实际为`int *(ar[])`，会误理解为int (\*ar)[]
+ `()的优先级高于*`：`int *fn()`实际为`int *(fn())`，会误理解为int (\*fn)()。函数指针和指针函数的区分为第一个词为返回类型，第二个词为本体内容。函数指针声明为`int (*p)(int);`

**函数**：函数返回指针不允许返回一个局部变量(即保存在栈区中)，必须给改变量声明为satic(即保存在数据区中)才可以

```c
#include <stdio.h>
#include <stdarg.h>

// 函数的可变参数使用如下：
double average(int num,...){// 第一个参数为参数个数，第二个为省略号用于可变参数
    va_list valist;// 创建一个va_list类型变量，该类型是在stdarg.h头文件中定义的
    
    va_start(valist, num);// 使用va_start宏初始化va_list变量为一个参数列表
 
    double sum = 0.0;
    for (int i = 0; i < num; i++)
    {
       sum += va_arg(valist, i);//使用va_arg宏和va_list变量来访问参数列表中的每个项
    }

    va_end(valist);// 使用宏va_end来清理赋予va_list变量的内存
 
    return sum/num;
}
```



**参考资料**

参考1：[《C语言入门教程》](http://c.biancheng.net/c/)

参考2：[《Linux C函数库参考手册》](https://www.linuxidc.com/Linux/2011-11/47913.htm)

