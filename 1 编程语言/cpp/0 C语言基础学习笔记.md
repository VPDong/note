## 编译过程

(1) 虽有很多IDE，但依然需要熟悉最基本的流程。代码会经过4个环节形成最终文件(更详细的可以参考《编译原理》)：

+ 预处理：去掉注释/展开头文件/宏替换/条件编译(但会保留#pragma编译器指令，因为编译器需要使用它们)

  通过`gcc -E hello.c -I <dir> -o hello.i`生成完整文件，`-I`指定头文件目录

+ 编译：检查词法\语法\语义，生成汇编

  通过`gcc -S hello.c -I <dir> -o hello.s`生成汇编文件，`-I`指定头文件目录

+ 汇编：汇编代码转换机器码

  通过`gcc -c hello.c -o hello.o`生成二进制文件，等同于`as hello.s -o hello.o`

+ 链接：链接到一起生成可执行程序

  通过`gcc hello.c -o hello`生成可执行程序。等同于`ld hello.o ... -o hello`

(2) 库是一种可执行代码的二进制形式，可以直接被操作系统载入内存执行。库文件分为静态库和动态库：

+ 动态库命令和特点：`gcc -c hello.c -o hello.o -fPIC && gcc hello.o -o libhello.so -shared && gcc main.c -o main -L<dir> -lhello`，在执行main之前**需要**将libhello.so拷贝到/usr/lib/路径下
+ 静态库命令和特点：`gcc -c hello.c -o hello.o && gar hello.o -crv libhello.a && gcc main.c -o main -L<dir> -lhello `，在执行main之前**不需**将libhello.so拷贝到/usr/lib/路径下
+ GCC常用参数整理如下(可参考[这里](http://c.biancheng.net/gcc/))：
  + `-I<dir>`：用来指定搜索头文件的路径。会先到所指定的目录查找，然后再按常规的顺序去找：常规是会先在当前目录查找头文件，如果没有找到会到默认的头文件目录找
  + `-L<dir>`：用来指定搜索库的路径。会先到所指定的目录查找，然后再按常规的顺序去找：在标准库的目录找
  + `-l<file>`：用来指定程序要链接的库(必须放到命令行最后)，如果文件不是以lib开头，则应该直接写上库名称
  + `-fPIC `：作用于编译阶段，告诉编译器产生与位置无关代码(Position-Independent Code)，这样一来产生的代码中就没有绝对地址了，全部使用相对地址，所以代码可以被加载器加载到内存的任意位置都可以正确的执行
  + `-shared`：此选项将尽量使用动态库，所以生成文件比较小
  + `-static`：此选项将禁止使用动态库，所以生成文件比较大
  + `-w\-Wall`:不生成\生成警告信息

(3) C与C++的互相调用

使用extern "C"是因为C编译器编译函数时不带参数的类型信息，只包含函数的符号名字。如int fn(float x)，C编译器会将此函数编译成类似`_fn`的符号，C连接器只要找到了调用函数的符号就认为连接成功。而C++编译器为了实现函数重载，会在编译时带上函数的参数信息，如它可以把上面的函数编译成类似于`_fn_float`这样的符号。

C++调用C，extern "C"的作用是：告诉C++连接器找调用函数符号时依照C的方式方式。

```
// C++调用C函数
// C Code
void fn(int x);

// C++ Code
extern "C" void fn(int x);
// todo
```

C调用C++，extern "C"的作用是：告诉C++编译器编译封装接口时依照C的方式。在日常使用中更多的是C++调用C，而非C调用C++。

```
// 基本思想是：C++会通过extern "C"来实现一个包包装器供C调用。

// C调用C++重载函数(须提供一个包装供C调用)
// C++ Code
void fn(int x);
void fn(float x);
extern "C" void fn_i(int x) {
    // tood
}
extern "C" void fn_f(float x) {
    // todo
}

// C Code
void fn_i(int x);
void fn_f(float x);
void test(int x1, float x2) {
    fn_i( x1 );
    fn_f( x2 );
    // todo
}

// C调用C++成员函数(须提供一个包装供C调用)
// C++ Code
class Clazz {
    virtual double fn(int);
};
extern "C" double call_Clazz_fn(Clazz* p, int i) {
    return p->fn(i);
}

//C code
double call_Clazz_fn(struct C* p, int i);
void test(struct Clazz* p, int i) {
   call_Clazz_fn(p,i);
   // todo
}
// 参数struct Clazz* p从哪里来(即怎么在C中定义C++对象)，真实的C中使用C++类需要把原来的类封装一下才能使用
```



## 内存结构

(1) 内存结构如下(地址由下往上增长)：

![](https://img-blog.csdn.net/20161029171857434)

+ 代码段：`.text`用来存放程序执行代码，同时也可能会包含一些常量(如一些字符串常量等)。它是静态分配的且只读(RO)的，同一程序内的多个相同进程存在时共用同一个
+ 数据段：分为`.gva`和`.bss`两段：
  + `.gva`：存放程序中**已经初始化的非零全局变量**。它是静态分配的且可分为只读(RO)区域(保存常量)和读写(RW)区域(普通非常全局变量，静态变量就在其中)
  + `.bss`： 存放程序中**未初始化(程序开始时通常会被清零)的或零值全局变量**。它是静态分配的(static标识变量保存在这里，不需要在每次它进入和离开作用域时进行创建和销毁)
+ 堆：`heap`是自由申请的空间，按内存地址由低到高方向生长。同一进程内的多个线程存在时共用同一个
+ 栈：`stack`：是程序运行的空间，按内存地址由高到低方向生长。每个线程都会有自己的栈

(2) 内存对齐基本规则如下：

+ 如没对内存对齐有明确要求，复合类型以其所有基本类型成员中最长成员的长度作为对齐的长度单位

  当复合类型为成员时，其在父类起始位置必须是C的整数倍，C的定义为该类型所有基本类型成员的最长成员长度

+ 如已对内存对齐有明确要求，可用`#pragma pack(n)`指定，以max(最长的成员长度,n)作为内存对齐的有效值



## 预处理器

(1) 常见的预处理器有如下：

+ \#include：导入源代码文件
+ \#define\\#undef：定义\取消宏
+ \#ifdef\\#if\\#else\\#elif\\#endif：条件编译
+ \#pragma：发布特殊的命令到编译器中，如`#pragma pack (n)`告诉编译器将按照n个字节对齐

\#define用来定义一个字符串常量(包括无参常量和有参常量)，是在预处理阶段进行字符串替换(不表达任何含义)，所以在使用宏定义时要特别注意优先级(注意添加外层括号)。typedef用类给数据类型起个新的别名，是在编译阶段执行解释的，其经常使用在结构\联合\枚举或指针声明一个新类型。

```c
#define ADD(a,b) a+b

int i = 1;
int j = 2;
int s = ADD(i,j) * 3;// 实际是i+j*3，并不是想象中的(i+j)*3

typedef struct Books
{
   char  title[50];
} Book;
Book book;
```

(2) C预处理器提供了下列的运算符来帮助创建宏：

+ `宏延续符(\)`：如果宏太长而单行容纳不下使用它
+ `参数解析符(#)`：当需要把参数转换成具体数值时使用它
+ `参数连接符(##)`：当需要把参数转换成具体数值和字符串连接成标记时使用它



## 特殊类型

**修饰**：const在c中分配内存到只读数据区中，在c++中分配内存到符号表中。表示是一个常量而不可修改。static在c++中表示是一个在数据区的变量，只是改变生命周期而不改变作用域。

**数组**：数组名为首元素的地址

**联合**：为联合体赋值一个成员后其他的成员数据可能受损，因其成员共用最大元素大小的内存

**结构**：结构体存在一种特殊的使用方式：[位域结构](https://www.runoob.com/cprogramming/c-bit-fields.html)

**指针**：**void \*** 为无类型指针，可指向任意类型的数据(常用来进行C中的泛型编程)，注意不允许对void指针进行一些算术运算(因为void是无类型，那么每次算术运算就不知道该操作几个字节)；**(char *)0**为地址为0的指针，通常用于进行判空处理。指针符号优先级如下(总结下来就是解析时从右边往左边解释)：

+ `.的优先级高于*`：`*p.f`实际为`*(p.f)`，会误理解为(\*p).f
+ `[]的优先级高于*`：`int *ar[]`实际为`int *(ar[])`，会误理解为int (\*ar)[]
+ `()的优先级高于*`：`int *fn()`实际为`int *(fn())`，会误理解为int (\*fn)()。**函数指针和指针函数的区分为第一个词为返回类型，第二个词为本体内容**。函数指针声明为`int (*p)(int);`

**函数**：关于函数的可变长参数使用如下：

```c
#include <stdio.h>
#include <stdarg.h>// 可变长参数几个宏定义在stdarg中

// 函数的可变参数使用如下：
double average(int num,...){// 第一个参数为参数个数，第二个为省略号用于可变参数
    va_list valist;// 创建一个va_list类型变量，该类型是在stdarg.h头文件中定义的

    va_start(valist, num);// 使用va_start宏初始化va_list变量为一个参数列表

    double sum = 0.0;
    for (int i = 0; i < num; i++) {
       sum += va_arg(valist, i);//使用va_arg宏和va_list变量来访问参数列表中的每个项
    }

    va_end(valist);// 使用宏va_end来清理赋予va_list变量的内存

    return sum/num;
}
```



## CPP的类

C是面向过程，C++是面向对象的(封装、继承、多态)。所以在C++中才有类的概念。

(1) 面向对象的特点：

+ 封装：将一系列的属性组装成一种类型，即具有结构属性。
+ 继承：类型之间具有亲属关系。
+ 多态：一个对象具有自身以及父类的特点，可以[动态绑定](https://www.jianshu.com/p/177c21837004)。

(2) 类的基本知识：

在学习之前记住一句话，**所有的继承都可以通过组合来解决**。

```c++
// 类的继承注意菱形继承问题，不然容易出现"二义性"，错误码为C2385。解决方式为虚继承(多态继承)
// 关于虚继承其实内存中只有一份根类，它解决数据冗余问题的同时也带来了性能上的损耗(不过虽然计算机性能提高可以忽略)
// https://blog.csdn.net/sssssuuuuu666/article/details/75736954
class Base[:virtual access_label class1[,virtual access_label class2...]] {
   access_label:
     // 数据成员
     // 函数成员(包含构造、析构、虚函数、友元等)
     Base();// 构造函数
     ~Base();// 析构函数
     virtual void virtualFn(Base base);// 虚函数(又叫多态函数，只要有一个纯虚函数(=0)，类则变为抽象类)
     friend void friendFn(Base base);// 友元函数(不可以被继承)
};

// 构造函数
Base::Base(void) {
    // todo
}
// 构造函数
Base::~Base(void) {
    // todo
}
// 虚函数
void Base::virtualFn(Base base) {
    // todo
}
// 友元函数(有权访问类的所有私有成员和保护成员,友元也可以是一个类，在这种情况下整个类及其所有成员都是友元)
void friendFn(Base base) {
    // todo
}
// 还有什么内联函数，自己另行查询(inline)
```



**参考资料**

参考1：[《C++菜鸟教程》](https://www.runoob.com/cplusplus/cpp-tutorial.html)

参考2：[《C语言入门教程》](http://c.biancheng.net/c/)

参考3：[《Linux C函数库参考手册》](https://www.linuxidc.com/Linux/2011-11/47913.htm)

