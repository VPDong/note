## 编译过程

(1) 虽有很多IDE，但依然需要熟悉最基本的流程。代码会经过4个环节形成最终文件(更详细的可以参考《编译原理》)：

+ 预处理：去掉注释/展开头文件/宏替换/条件编译(但会保留#pragma编译器指令，因为编译器需要使用它们)

  通过`gcc -E hello.c -I <dir> -o hello.i`生成完整文件，`-I`指定头文件目录

+ 编译：检查词法\语法\语义，生成汇编

  通过`gcc -S hello.c -I <dir> -o hello.s`生成汇编文件，`-I`指定头文件目录

+ 汇编：汇编代码转换机器码

  通过`gcc -c hello.c -o hello.o`生成二进制文件，等同于`as hello.s -o hello.o`

+ 链接：链接到一起生成可执行程序

  通过`gcc hello.c -o hello`生成可执行程序。等同于`ld hello.o ... -o hello`

(2) 库是一种可执行代码的二进制形式，可以直接被操作系统载入内存执行。库文件分为静态库和动态库：

+ 动态库命令和特点：`gcc -c hello.c -o hello.o -fPIC && gcc hello.o -o libhello.so -shared && gcc main.c -o main -L<dir> -lhello`，在执行main之前**需要**将libhello.so拷贝到/usr/lib/路径下
+ 静态库命令和特点：`gcc -c hello.c -o hello.o && gar hello.o -crv libhello.a && gcc main.c -o main -L<dir> -lhello `，在执行main之前**不需**将libhello.so拷贝到/usr/lib/路径下
+ GCC常用参数整理如下(可参考[这里](http://c.biancheng.net/gcc/))：
  + `-I<dir>`：用来指定搜索头文件的路径。会先到所指定的目录查找，然后再按常规的顺序去找：常规是会先在当前目录查找头文件，如果没有找到会到默认的头文件目录找
  + `-L<dir>`：用来指定搜索库的路径。会先到所指定的目录查找，然后再按常规的顺序去找：在标准库的目录找
  + `-l<file>`：用来指定程序要链接的库(必须放到命令行最后)，如果文件不是以lib开头，则应该直接写上库名称
  + `-fPIC `：作用于编译阶段，告诉编译器产生与位置无关代码(Position-Independent Code)，这样一来产生的代码中就没有绝对地址了，全部使用相对地址，所以代码可以被加载器加载到内存的任意位置都可以正确的执行
  + `-shared`：此选项将尽量使用动态库，所以生成文件比较小
  + `-static`：此选项将禁止使用动态库，所以生成文件比较大
  + `-w\-Wall`:不生成\生成警告信息



## 内存结构

(1) 内存结构如下(地址由下往上增长)：

![](https://img-blog.csdn.net/20161029171857434)

+ 代码段：`.text`用来存放程序执行代码，同时也可能会包含一些常量(如一些字符串常量等)。它是静态分配的且只读(RO)的，同一程序内的多个相同进程存在时共用同一个
+ 数据段：分为`.gva`和`.bss`两段：
  + `.gva`：存放程序中**已经初始化的非零全局变量**。它是静态分配的且可分为只读(RO)区域(保存常量)和读写(RW)区域(普通非常全局变量，静态变量就在其中)
  + `.bss`： 存放程序中**未初始化(程序开始时通常会被清零)的或零值全局变量**。它是静态分配的(static标识变量保存在这里，不需要在每次它进入和离开作用域时进行创建和销毁)
+ 堆：`heap`是自由申请的空间，按内存地址由低到高方向生长。同一进程内的多个线程存在时共用同一个
+ 栈：`stack`：是程序运行的空间，按内存地址由高到低方向生长。每个线程都会有自己的栈

(2) 内存对齐基本规则如下：

+ 如没对内存对齐有明确要求，复合类型以其所有基本类型成员中最长成员的长度作为对齐的长度单位

  当复合类型为成员时，其在父类起始位置必须是C的整数倍，C的定义为该类型所有基本类型成员的最长成员长度

+ 如已对内存对齐有明确要求，可用`#pragma pack(n)`指定，以max(最长的成员长度,n)作为内存对齐的有效值



## 预处理器

(1) 常见的预处理器有如下：

+ \#include：导入源代码文件
+ \#define\\#undef：定义\取消宏
+ \#ifdef\\#if\\#else\\#elif\\#endif：条件编译
+ \#pragma：发布特殊的命令到编译器中，如`#pragma pack (n)`告诉编译器将按照n个字节对齐

\#define用来定义一个字符串常量(包括无参常量和有参常量)，是在预处理阶段进行字符串替换(不表达任何含义)，所以在使用宏定义时要特别注意优先级(注意添加外层括号)。typedef用类给数据类型起个新的别名，是在编译阶段执行解释的，其经常使用在结构\联合\枚举或指针声明一个新类型。

```c
#define ADD(a,b) a+b

int i = 1;
int j = 2;
int s = ADD(i,j) * 3;// 实际是i+j*3，并不是想象中的(i+j)*3

typedef struct Books
{
   char  title[50];
} Book;
Book book;
```

(2) C预处理器提供了下列的运算符来帮助创建宏：

+ `宏延续符(\)`：如果宏太长而单行容纳不下使用它
+ `参数解析符(#)`：当需要把参数转换成具体数值时使用它
+ `参数连接符(##)`：当需要把参数转换成具体数值和字符串连接成标记时使用它



## 特殊类型

**数组**：数组名为首元素的地址

**联合**：为联合体赋值一个成员后其他的成员数据可能受损，因其成员共用最大元素大小的内存

**结构**：结构体存在一种特殊的使用方式：[位域结构](https://www.runoob.com/cprogramming/c-bit-fields.html)

**指针**：**void \*** 为无类型指针，可指向任意类型的数据(常用来进行C中的泛型编程)，注意不允许对void指针进行一些算术运算(因为void是无类型，那么每次算术运算就不知道该操作几个字节)；**(char *)0**为地址为0的指针，通常用于进行判空处理。指针符号优先级如下(总结下来就是解析时从右边往左边解释)：

+ `.的优先级高于*`：`*p.f`实际为`*(p.f)`，会误理解为(\*p).f
+ `[]的优先级高于*`：`int *ar[]`实际为`int *(ar[])`，会误理解为int (\*ar)[]
+ `()的优先级高于*`：`int *fn()`实际为`int *(fn())`，会误理解为int (\*fn)()。**函数指针和指针函数的区分为第一个词为返回类型，第二个词为本体内容**。函数指针声明为`int (*p)(int);`

**函数**：关于函数的可变长参数使用如下：

```c
#include <stdio.h>
#include <stdarg.h>// 可变长参数几个宏定义在stdarg中

// 函数的可变参数使用如下：
double average(int num,...){// 第一个参数为参数个数，第二个为省略号用于可变参数
    va_list valist;// 创建一个va_list类型变量，该类型是在stdarg.h头文件中定义的

    va_start(valist, num);// 使用va_start宏初始化va_list变量为一个参数列表

    double sum = 0.0;
    for (int i = 0; i < num; i++) {
       sum += va_arg(valist, i);//使用va_arg宏和va_list变量来访问参数列表中的每个项
    }

    va_end(valist);// 使用宏va_end来清理赋予va_list变量的内存

    return sum/num;
}
```



**参考资料**

参考1：[《C语言入门教程》](http://c.biancheng.net/c/)

参考2：[《Linux C函数库参考手册》](https://www.linuxidc.com/Linux/2011-11/47913.htm)

