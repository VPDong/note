## 一、代码生成

这里以c语言为例，进行相关步骤的记录：

+ 预处理：去掉注释/展开头文件/宏替换/条件编译(但会保留#pragma编译器指令，因为编译器需要使用它们)

  通过`gcc -E hello.c -I <dir> -o hello.i`生成完整文件，`-I`指定头文件目录

+ **编译：检查词法\语法\语义，生成汇编**

  **通过`gcc -S hello.c -I <dir> -o hello.s`生成汇编文件，`-I`指定头文件目录**

+ 汇编：汇编代码转换机器码

  通过`gcc -c hello.c -o hello.o`生成二进制文件，等同于`as hello.s -o hello.o`

+ 链接：链接到一起生成可执行程序

  通过`gcc hello.c -o hello`生成可执行程序。等同于`ld hello.o ... -o hello`



## 二、基础知识

### 2.1 模式状态

ARM处理器支持用户模式和特权模式，具体有以下运行模式：

+ 用户模式(usr)：正常的程序执行状态(因此只学习该模式下指令)。*只能访问常规寄存器*
+ 系统模式(sys)：运行具有特权的操作系统任务。*只能访问常规寄存器*
+ 管理模式(svc)：操作系统使用的保护模式
+ 中断模式(irq\fiq)：用于通用的中断处理\用于高速数据传输或通道处理
+ 终止模式(abt\und)：用于虚拟存储及存储保护\当未定义的指令执行时进入该模式

ARM处理器在Thumb和ARM两种工作状态中随意切换。运行于Thumb状态时，执行的的16位字对齐的指令；运行于ARM状态时，执行的的32位字对齐的指令。

### 2.2 寄存器定义

ARM微处理器共有37个32位寄存器(其中31个为通用寄存器，6个为状态寄存器)，但是这些寄存器不能被同时访问，具体哪些寄存器是可以访问的，取决ARM处理器具体的运行模式和工作状态。**但在任何时候，通用寄存器R0~R14、程序计数器PC、一个状态寄存器CPSR都是可访问的**。

+ 未分组寄存器：R0-R7是不分组寄存器。这意味着在所有处理器模式下，访问的都是同一个物理寄存器。不分组寄存器没有被系统用于特别的用途，任何可采用通用寄存器的应用场合都可以使用未分组寄存器。

+ 已分组寄存器：R8-R14是已分组寄存器。**首先了解一个概念：每个函数所使用的栈空间是一个栈帧**。R11用作(栈)帧指针FP，指向当前函数栈帧的栈底；R12用作内部调用指针IP，暂时当作通用寄存器；R13用作栈指针SP，指向当前函数栈帧的栈顶；R14用作链接寄存器LP，指向函数的返回地址；R15被用作程序计数器PC，指向当前正在执行的指令的地址+8(因为在取地址和执行之间多了一个译码的阶段)。

  下面以一个例子图进行理解：栈的方向为向下增长，栈底在高地址而栈顶在低地址。fp、sp、lr、pc这四个寄存器是非常特殊的寄存器，它们记录了当前正在运行的函数一些重要信息。main stack frame为先前调用函数的栈帧，func1 stack frame为当前函数的栈帧。**在刚进入一个新的函数开始执行的时候，需要将上个函数入栈保存起来！参数入栈顺序是从右到左依次入栈，而参数的出栈顺序则是从左到右的出栈。**

  ![](https://img-blog.csdn.net/20160817105557618?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

+ 状态寄存器：CPSR包含条件码标志、中断禁止位、当前处理器模式以及其他状态和控制信息，主要用于运行模式、运算指令的信息记录等。

  ![](https://img-blog.csdn.net/20161028225855208)



## 三、寻址方式

### 3.1 相对寻址

如`BL NEXT`以程序计数器PC的当前数值为基地址，指令中的地址标号作为偏移量，两者相加后的数值赋值给R0

### 3.2 立即寻址

如`MOV R0,#0x12`将十六进制0x12数值赋值给R0

如`MOV R0,R1`将寄存器R1的数值赋值给R0

如`MOV R0,R1,LSL #2`将寄存器R1的数值左移2位后的数值赋值给R0

### 3.3 间接寻址

如`LDR R0,[R1]`将寄存器R1的数值作为地址，取该地址存储单元的数值赋值给R0

如`LDR R0,[R1,#-4]`将寄存器R1的数值减去4作为地址，取该地址存储单元的数值赋值给R0

### 3.4 特别寻址

+ **堆栈寻址**：

  如`LDMFD SP!,{R1-R7,LR}`将数据出栈到R1-R7以及LR，多用于恢复子程序"现场"；

  如`STMFD SP!,{R1-R7,LR}`将R1-R7以及LR的数据入栈，多用于保存子程序"现场"

+ **存储寻址**

  如`LDMIA R0!,{R1-R3}`从寄存器R0指向的存储单元读取3个字到R1-R3寄存器中

  如`STMIA R0!,{R1-R3}`存储R1-R3寄存器的内容到寄存器R0指向的内存单元

+ **多寄存器寻址**：

  如`LDMIA R0,{R1,R2,R3}`将寄存器[R0]依次赋值给花括号中的寄存器，每次赋值完后R0根据规则运算，这里IA表示每次自增1字节，因此R1=[R0]\R2=[R0+#4]\R3=[R0+#8]



## 四、语法结构

### 4.1 指令格式

ARM指令的基本格式为：`<opcode>{<cond>}{S}{.W\.N} {Rd},{Rn}{,<operand2>}`

+ opcode为指令助记符，如MOV等，这也是理解记忆的重点
+ cond为执行条件，取值见下图。正常来说，只要相对理解指令即可，不用强记条件
+ S为指令是否影响CPSR的值，如ADDS\SUBS等指令会影响
+ .W\\.N为指令宽度说明符号，暂时忽略
+ 剩下的为寄存器和操作数

```txt
  条件码 助记符后缀        标 志                 含 义
  0000    EQ            Z置位                 相等
  0001    NE            Z清零                 不相等

  0010    CS/HS         C置位                 无符号数大于或等于
  0011    CC/LO         C清零                 无符号数小于
  
  0100    MI            N置位                 负数
  0101    PL            N清零                 正数或零

  0110    VS            V置位                 溢出
  0111    VC            V清零                 未溢出

  1000    HI            C置位Z清零             无符号数大于
  1001    LS            C清零Z置位             无符号数小于或等于

  1010    GE            N等于V                带符号数大于或等于
  1011    LT            N不等于V               带符号数小于
  1100    GT            Z清零且(N等于V)        带符号数大于
  1101    LE            Z置位或(N不等于V)       带符号数小于或等于

  1110    AL            忽略                  无条件执行
  1111    NV            忽略
```



### 4.2 指令内容

跳转：





## 四、语句解析



## 五、文件结构



