[TOC]

## 一、内存区域

Java虚拟机在执行Java程序的过程中会把管理内存划分成若干个不同的数据区域。JDK1.8 和之前的版本略有不同：

![](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/2019-3Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png)

### 1.1 线程私有内存

#### 1.1.1 程序计数器

作用：程序计数器是一块较小的内存空间，是用于记录当前线程所执行字节码的行号指示器：

+ 从单线程的情况下考虑，字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如顺序执行、分支条件、异常处理、线程恢复。
+ 从多线程的情况下考虑，从而当线程被切换回来的时候能恢复到先前正确的执行位置。

注意：程序计数器是唯一不会出现OOM的内存区域，它的生命周期和线程相同。

#### 1.1.2 虚拟机栈

作用：虚拟机栈是一块较大的内存空间，是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递：

+ 从整体来看，虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。

  > **局部变量表主要存放了编译期可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄）。

+ 从过程来看，每一次函数调用都会有一个对应的栈帧被入栈，每一个函数调用结束后都会有一个栈帧被弹出。Java方法有return语句、抛出异常两种返回方式，不管哪种返回方式都会导致栈帧被弹出。

注意：**虚拟机栈会出现两种错误：`OutOfMemoryError` 和 `StackOverFlowError`：**

+ **`OutOfMemoryError`：** 若虚拟机堆中没有空闲内存，且垃圾回收器也无法提供更多内存的话，就会抛出OutOfMemoryError错误。
+ **`StackOverFlowError`：** 若虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前虚拟机栈的最大深度的时候，就抛出StackOverFlowError错误。

#### 1.1.3 本地方法栈

作用：和虚拟机栈所发挥的作用非常相似，区别是：**虚拟机栈为虚拟机执行Java 方法（也就是字节码），而本地方法栈则为虚拟机使用到的 Native 方法。在 HotSpot虚拟机中两栈合二为一。** 从整体和过程来看，与虚拟机栈作用基本一致。

注意：方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `OutOfMemoryError` 和 `StackOverFlowError`两种错误。

### 1.2 线程共享内存

#### 1.2.1 堆内存

作用：堆在虚拟机启动时创建，**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。其实可以理解为局部变量。

> 但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”。

结构：堆是垃圾收集器管理的主要区域，因此也被称作**GC堆（Garbage Collected Heap）。**从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以堆还可以细分为：新生代（Eden空间、From Survivor空间、To Survivor空间）和老年代。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**

> 在 JDK7版本及之前，堆内存被通常被分为三部分：新生代、老年代、永生代。
>
> 在JDK8 版本及之后，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。

![](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.png)

大部分情况对象会首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活则会进入s0或s1，且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度，就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 `-XX:MaxTenuringThreshold` 来设置。

Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值：

```c++
uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {//survivor_capacity是survivor空间的大小
  size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100);
  size_t total = 0;
  uint age = 1;
  while (age < table_size) {
    total += sizes[age];//sizes数组是每个年龄段对象大小
    if (total > desired_survivor_size) break;
    age++;
  }
  uint result = age < MaxTenuringThreshold ? age : MaxTenuringThreshold;
  //...
}

```

注意：**堆最容易出现的是`OutOfMemoryError`错误，且出现这种错误之后的表现形式会有几种：**

+ **`OutOfMemoryError: GC Overhead Limit Exceeded`** ： 当JVM花太多时间执行垃圾回收且只能回收很少堆空间时，会发生此错误。
+ **`OutOfMemoryError: Java heap space`** ：假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象，会引发该错误。(和本机物理内存无关，和配置的内存大小有关)
+ ...

#### 1.2.2 方法区

作用：方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 **Java虚拟机规范把方法区描述为堆的一个逻辑部分**，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的是与Java堆区分开来。

+ 方法区和永久代关系：《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它，在不同的 JVM上方法区的实现是不同的。**方法区和永久代的关系很像接口和类的关系，永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。** 也就是说，方法区是Java虚拟机规范中的定义，是一种规范；永久代是HotSpot的概念，是一种实现。
+ 元空间替换永生代原因（用元空间实现方法区）：
  + 从空间容量上看：整个永生代有一个JVM本身设置固定大小上限而无法进行调整。而元空间使用的是直接内存，受本机可用内存的限制。虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。元空间溢出时会得到这样的错误： `OutOfMemoryError: MetaSpace`。
  + 从存储数据上看：元空间里面存放的是类的元数据，这样加载多少类的元数据不由 `MaxPermSize` 控制， 而由系统的实际可用空间来控制，这样能加载的类就会更多。
  + 从代码整合上看：在JDK8，合并HotSpot和JRockit的代码时, JRockit从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永生代的地方。

数据：Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量(如文本字符串、声明为final的常量值等)和符号引用(类和接口的全限定名、字段的名称和描述符、方法的名称和描述符)）。运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError错误。

> + JDK1.6运行时常量池（包含字符串常量池）存放在方法区，此时hotspot虚拟机对方法区的实现为永久代。
> + JDK1.7字符串常量池被从方法区拿到了堆中，运行时常量池剩下的东西还在方法区，也就是hotspot中的永久代。
> + JDK1.8用元空间替代了永生代，此时字符串常量池还在堆，运行时常量池还在方法区，只不过方法区的实现从永生代变成了元空间(Metaspace)。

参数：通常通过下面这些参数来调节方法区大小：

+ 永久代还没被彻底移除的时候：
  + -XX:PermSize=N：方法区 (永生代) 初始大小
  + -XX:MaxPermSize=N：方法区 (永生代) 最大大小，超过这个值将会抛出OutOfMemoryError异常：java.lang.OutOfMemoryError: PermGen

+ 元空间替换永生代之后：
  + -XX:MetaspaceSize=N：设置 Metaspace 的初始大小
  + -XX:MaxMetaspaceSize=N：设置Metaspace的最大大小，与永生代不同的是，如果不指定大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存

#### 1.2.3 直接内存

**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError错误出现。**

> JDK1.4中新加入的**NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）**与**缓存区（Buffer）**的 I/O 方式。它可以使用Native函数库直接分配堆外内存，然后通过一个存储在 Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在Java堆和Native堆之间来回复制数据**。



## 二、对象探秘

### 2.1 对象的创建

内存布局：在Hotspot虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头**、**实例数据**和**对齐填充**。

+ 对象头：**包括两部分信息，第一部分是动态信息(对象自身运行时数据)，**如对象的哈希码、对象的GC分代年龄、是否启用偏向锁等信息，**另一部分是静态信息(类型指针)**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。
+ 实例数据：**是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。
+ 对齐填充：该部分不是必然存在的，仅仅起占位作用。因Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，而对象头部分正好是8字节的倍数(1倍或2倍)，因此当对象实例数据部分没有对齐时，就需通过对齐填充来补全。

创建过程：下图便是 Java 对象的创建过程：

```mermaid
graph LR
    A(加载检查) -->B(分配内存)
    B --> C(初始化零值)
    C --> D(设置对象头)
    D --> F(执行init方法)
```

+ 加载检查：虚拟机遇到一条new指令时，首先将去检查是否能在常量池中定位到这个类(new指令的参数)的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有则必须先执行相应的类加载过程。

+ 分配内存：对象所需内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。

  + **分配方式**：有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择哪种分配方式由Java堆是否规整决定，堆内存是否规整，取决于GC收集器的算法是"标记-清除"，还是"标记-整理"。注意复制算法内存也是规整的。**

    ![](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F.png)

  + **分配并发**：创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的。虚拟机采用两种方式来保证线程安全：

    **TLAB：**为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用下述的CAS进行内存分配

    **CAS+失败重试：**虚拟机采用CAS(是乐观锁的一种实现方式)配上失败重试的方式保证更新操作的原子性。

+ 初始化零值：虚拟机需要将分配的内存空间都初始化为零值(不包括对象头)，该操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

+ 设置对象头：虚拟机要对对象进行必要的设置，例如对象的哈希码、对象的GC分代年龄、是否启用偏向锁等信息，以及类型指针。 这些信息存放在对象头中。

+ 执行init方法：从虚拟机的视角来看，一个新的对象已经产生。但从 Java 程序的视角来看，对象创建才刚开始。一般来说，执行new指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化。

### 2.2 对象的访问

创建对象就是为了使用对象，Java程序通过栈上的reference数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有**直接指针**和**使用句柄**两种：

+ 直接指针：如使用直接指针访问，Java堆会划分出一块内存来存放到对象类型数据的指针和实例数据，而reference中存储的直接就是对象的地址。

  ![](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88.png)

+ 使用句柄：如果使用句柄访问，Java堆中会划分出一块内存来作为句柄池，而reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

  ![](https://snailclimb.gitee.io/javaguide/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D-%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84.png)



## 三、常量池技术

**String 类型的常量池比较特殊。它的主要使用方法有两种：**

+ 直接使用双引号声明出来的 String 对象会直接存储在常量池中。
+ 如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。

```java
String s1 = new String("计算机");
String s2 = s1.intern();
String s3 = "计算机";
System.out.println(s2);//计算机
System.out.println(s1 == s2);//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，
System.out.println(s3 == s2);//true，因为两个都是常量池中的 String 对象
```

**Java 基本类型的包装类的大部分都实现了常量池技术，即 Boolean、Character、Byte、Short、Integer、Long；Boolean直接返回True Or False，Character创建了数值在[0,127]范围的缓存数据，后面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，如果超出对应范围仍然会去创建新的对象。** 为啥把缓存设置为[-128，127]区间？性能和资源之间的权衡。

```java
Integer i = 40；//编译时会将代码封装成Integer i=Integer.valueOf(40);从而使用常量池中的对象。
Integer j = new Integer(40); //这种情况下会创建新的对象
```

