# CSRF漏洞详解

跨站请求伪造CSRF(Cross-Site Request Forgery)存在巨大的危害性。是指利用受害者尚未失效的身份认证信息(cookie、会话等)，**诱骗其点击恶意链接或者访问包含攻击代码的页面**，在受害人不知情的情况下以受害者的身份向(身份认证信息所对应的)服务器发送请求，从而完成非法操作(如转账、改密等)。CSRF与XSS最大的区别就在于CSRF并没有盗取cookie而是直接利用。

## 原理

发起一个请求时，request header里面有三个属性会涉及请求源信息，分别是Host、**Referer**、Origin。前端可能用不到这些值，但是后台业务系统会比较关心它们。

+ Host描述请求将被发送的目的地，包括域名和端口号。这个参数存在于任何类型请求中
+ **Referer**用来说明当前请求来源页面的地址(即表示当前页面是通过此来源页面里的链接进入的)，包括协议+域名+查询参数(注意不包含锚点信息)。这个参数适用于任何类型请求中。一般用来防盗链
+ Origin用来说明请求从哪里发起的，包括协议和域名。这个参数一般只存在于CORS跨域请求中

当服务端没有校验Referer字段或没有其他手段进行来源校验时，恶意链接被用户点击时就可能发生CSRF漏洞。

> 这里会有疑问：恶意链接被执行时难道不会被同源策略阻止吗？同源策略不能作为防范CSRF的方法，因为SOP并不是禁止跨域请求，而是在请求后拦截了请求的回应。跨域资源的引入如`<script>`、**页面中的链接**、**页面中的表单提交**、重定向等是不会受到同源策略限制的。因此CSRF正好躲避了同源的限制。

## 流程

```sequence
participant 黑客
participant 用户
participant 正常服务器
participant 恶意服务器

黑客->正常服务器:发现正常服务器的CSRF漏洞(由于没有验证请求来源身份)
黑客->恶意服务器:设计恶意网站
用户->正常服务器:登陆并浏览正常网站
正常服务器-->用户:返回验证通过，并在用户浏览器设置cookie
用户->恶意服务器:用户在没有退出正常网站情况下访问恶意网站
恶意服务器-->用户:返回带有恶意脚本(访问正常网站)的网页
用户->正常服务器:点击链接或表单提交，执行恶意访问(带着正常网站的cookie且referer为恶意网站地址)
正常服务器-->正常服务器:没有校验来源身份，执行恶意脚本发出的请求(如转账等)
```

因此CSRF漏洞利用有两种方式：

+ GET型的CSRF漏洞只需要构造URL，然后诱导受害者访问利用
+ POST型的CSRF漏洞，需要构造自动提交或点击提交的表单，然后诱导受害者访问或点击利用

## 对抗

**1、验证HTTP Referer字段**

根据HTTP协议，在HTTP头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。当用户通过黑客的网站发送请求到银行时，该请求的Referer是指向黑客自己的网站。因此要防御CSRF攻击，银行网站只需要对于每一个转账请求验证其Referer值。如果Referer是其他网站的话，则有可能是黑客的CSRF攻击，拒绝该请求。

这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心CSRF的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查Referer的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑非常便捷。然而这种方法并非万无一失。原因有两个：

+ Referer的值是由浏览器提供的，虽然HTTP协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证Referer值的方法，就是把安全性都依赖于第三方(即浏览器)来保障，从理论上来讲这样并不安全。事实上对于某些浏览器，比如IE6或FF2，目前已经有一些方法可以篡改Referer值
+ 即便是使用最新的浏览器，黑客无法篡改Referer值，这种方法仍然有问题。因为Referer值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心Referer值会把组织内网中的某些信息泄露到外网中。因此用户自己可以设置浏览器使其在发送请求时不再提供Referer。当他们正常访问银行网站时，网站会因为请求没有Referer值而认为是 CSRF 攻击，拒绝合法用户的访问。

**2、在请求内容中添加token并验证 **

CSRF攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中，可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。这种方法要比检查Referer要安全一些，token可以在用户登陆后产生并放于session之中，然后在每次请求时把token从session中拿出，与请求中的token进行比对。

这种方法的缺点是需要很麻烦的把token以参数的形式加入请求。对于GET请求，token将附在请求地址之后，这样URL就变成 http://url?csrftoken=tokenvalue。 而对于POST请求来说，要在form的最后加上 ，这样就把token以参数的形式加入请求了。但是在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上token是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript遍历整个dom树，对于dom中所有的a和 form标签后加入token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的html代码，这种方法就没有作用，还需要程序员在编码时手动添加token。    

该方法还有一个缺点是难以保证token本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上token，黑客可以在自己的网站上得到这token，并马上就可以发动CSRF攻击。为了避免这一点，系统可以在添加token的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加token，如果是通向外网则不加。不过即使这个csrftoken不以参数的形式附加在请求之中，黑客的网站也同样可以通过Referer来得到这个token值以发动CSRF攻击。这也是一些用户喜欢手动关闭浏览器Referer功能的原因。

**3、在请求头中添加token并验证**

这种方法也是使用token并进行验证，和上一种方法不同的是，这里并不是把token以参数的形式置于HTTP请求之中，而是把它放到HTTP头中自定义的属性里。通过XMLHttpRequest这个类，可以一次性给所有该类请求加上CSRFToken这个HTTP头属性，并把token值放入其中。这样解决了上种方法在请求中加入token的不便，同时通过XMLHttpRequest请求的地址不会被记录到浏览器的地址栏，也不用担心token会透过Referer泄露到其他网站中去。        

然而这种方法的局限性非常大。XMLHttpRequest请求通常用于Ajax方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进、后退、刷新、收藏等操作，给用户带来不便。另外对于没有进行CSRF防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为XMLHttpRequest请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。

**4、针对关键请求进行二次验证**

这个就不需多说了，各种验证码层出不穷。

## 挖掘

+ 最简单的方法就是抓取一个正常请求的数据包，如果没有Referer字段和token，那么极有可能存在CSRF漏洞
+ 如有Referer字段，但是去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞

随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞进行检测的工具，如CSRFTester，CSRF Request Builder等。 BurpSuite可以抓包后快速生成CSRF POC。以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞。

相关实践看这里[《CSRF实战攻防》](https://mp.weixin.qq.com/s?__biz=MzI4NjEyMDk0MA==&mid=2649848651&idx=1&sn=0876a8256d22c36e7111579680328bc4&chksm=f3e415c8c4939cde89926b21c393c1c2db116337ff398634e22b477442af02d04df27be9c448&mpshare=1&scene=1&srcid=&sharer_sharetime=1575252752903&sharer_shareid=246ae72ebf3b2af5c45fe95d5f09f3d1&key=3f40946aa1882f680a0b697ad8ba64ee486659a67535b8e17ccd4801bc291a09b917309a3ed8a723c7c377017d4b87a7327923ee8cd812422ebfa8ee5959c14012d1fb39446ee78120f6e6bed0694551&ascene=1&uin=MjIwMDQzNjQxOQ%3D%3D&devicetype=Windows-QQBrowser&version=6103000b&lang=zh_CN&pass_ticket=IpeXxy30DmozYuDVsgikAA4PPKR5v3xZAypiFog%2FoRfDTp%2BSYBZeGnp12WW696QT)。